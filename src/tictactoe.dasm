; TODO You may want to change the copyright of all files. This is the
; TODO ISC license. Choose another one if you want.
;
; Copyright (c) 2015 Joe Jackson <cpmhjoe@gmail.com>
;
; Permission to use, copy, modify, and/or distribute this software for any
; purpose with or without fee is hereby granted, provided that the above
; copyright notice and this permission notice appear in all copies.
;
; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
; WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
; MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
; ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
; ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
; OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

  processor 6502
  include "vcs.h"
  include "macro.h"

;------------------------------------------------------------------------------
; Variables

  seg.u vars
  org $80                             ; start of RAM

; pointers to the graphics for each slot
Pos0GrPtr ds 2
Pos1GrPtr ds 2
Pos2GrPtr ds 2
Pos3GrPtr ds 2
Pos4GrPtr ds 2
Pos5GrPtr ds 2
Pos6GrPtr ds 2
Pos7GrPtr ds 2
Pos8GrPtr ds 2

; Player Cursor xPos (0-2) yPos (0-2)
PlayerXpos ds 1
PlayerYpos ds 1

; Temporary Pointer
TempPtr ds 2

PreviousJoyStickState ds 1

; PlayerBoards These are just a bitmat for each player to check win states, and
; next moves this structure looks like this
;
; bit0 | bit1 | bit2
;------+------+-----
; bit3 | bit4 | bit5
;------+------+-----
; bit6 | bit7 | Byte2bit0
;
HumanPlayerBoard ds 2
ComputerPlayerBoard ds 2

FrameCount ds 1
PlayerButtonActive ds 1

; 27 bytes 229 left

;------------------------------------------------------------------------------

  seg
  org $F000

Reset
  ; clear RAM and all TIA registers

  ldx #0
  lda #0
Clear sta 0,x
  inx
  bne Clear

  ldx #$FF
  txs                                 ; set stack pointer

;------------------------------------------------------------------------------
; Once only initialization

  lda #%00000001                      ; reflected playfield
  sta CTRLPF

  lda #$0e                            ; white board
  sta COLUPF                          ; set playfield color

  lda #$46
  sta COLUP0                          ; Player Sprite is Red

  ; load all of slots with empty graphics
  lda #<BlankEdge
  sta Pos0GrPtr
  lda #>BlankEdge
  sta Pos0GrPtr+1

  lda #<BlankMiddle
  sta Pos1GrPtr
  lda #>BlankMiddle
  sta Pos1GrPtr+1

  lda #<BlankEdge
  sta Pos2GrPtr
  lda #>BlankEdge
  sta Pos2GrPtr+1

  lda #<BlankEdge
  sta Pos3GrPtr
  lda #>BlankEdge
  sta Pos3GrPtr+1

  lda #<BlankMiddle
  sta Pos4GrPtr
  lda #>BlankMiddle
  sta Pos4GrPtr+1

  lda #<BlankEdge
  sta Pos5GrPtr
  lda #>BlankEdge
  sta Pos5GrPtr+1

  lda #<BlankEdge
  sta Pos6GrPtr
  lda #>BlankEdge
  sta Pos6GrPtr+1

  lda #<BlankMiddle
  sta Pos7GrPtr
  lda #>BlankMiddle
  sta Pos7GrPtr+1

  lda #<BlankEdge
  sta Pos8GrPtr
  lda #>BlankEdge
  sta Pos8GrPtr+1

  ; set player to 0,0
  lda #1
  sta PlayerXpos
  lda #1
  sta PlayerYpos

  ; quadruple sprite size
  lda #%0000111
  sta NUSIZ0

;------------------------------------------------------------------------------
; Main Loop
Main
  jsr VerticalSync  ; 6 Jump to Vertical Sync
  jsr VerticalBlank ; 6 Jump to Vertical Blank
  jsr Kernel        ; 6 Jump to Kernel
  jsr Overscan      ; 6 Jump to Overscan
  jmp Main

;------------------------------------------------------------------------------
; VerticalSync Subroutine
VerticalSync
  lda #2      ; 2 Load with 2 so D1=1 to turn on VSYNC signal
  ldx #49

  sta WSYNC
  sta VSYNC ; D1=1 turns the Vertical Sync signal on
  stx TIM64T ; set timer to go of in 41 scanlines 49 = (41 * 76) / 64

  sta WSYNC
  sta WSYNC

  lda #0
  sta WSYNC                           ; 3rd scanline of VSYNC signal
  sta VSYNC                           ; D1 = 0 Turns Off VSYNC signal
  rts

;------------------------------------------------------------------------------
; VerticleBlank Subroutine 37 lines 37 * 76 = 2815 cycles max

VerticalBlank
  lda INPT4
  bmi ButtonNotPressed

  lda PlayerYpos   ; load y-pos and multiply by 3
  clc              ; clear the carry
  adc PlayerYpos
  adc PlayerYpos

  adc PlayerXpos  ; get final position ex y=1 x=2  3 x 1 + 2 = 5
  tay             ; transfer a to y for storage

  ;------------------------------------------------------------------------------
  ; Add position to player board

  tax             ; 2 (2) transfer player position to x to countdown 2^(player_pos)
                  ; changing 0 into 0000 0001 and 8 into 1000 0000
  lda #0          ; 2 (4) prime a
  sec             ; 2 (6) prime for the loop if one pass (0) you will get 00000001
PosCountdown
  rol             ; 2 (8-first-pass) shift left
  dex             ; 2 (10-first-pass) count down
  bpl PosCountdown  ; 3[2] (14-first-pass) loop until negative
                  ; 0 will go through the loop once and will be negative
                  ; 8 will go through the loop 9 times and be negative when the
                  ; carry is set again
                  ; 50(worst case) 13(best case)
  ora HumanPlayerBoard ; 3 (53) Add the position to the player board
  sta HumanPlayerBoard ; 3 (56)
  bcc SkipSetPlayerTopPos ; 3[2] (59)
  lda #1          ; 2 (61) Load a 1 into the playboard high byte if the carry is set
  sta HumanPlayerBoard+1 ; 3 (64)

SkipSetPlayerTopPos

  tya             ; 2 (66) store player position back into a
  ;------------------------------------------------------------------------------
  ; Add Player Graphic To Board
  asl             ; multipy by 2 to get offset

  tay             ; transfer a to y

  lda PlayerXpos  ; check if xpos is middle
  cmp #1
  beq AddMiddle

  lda #<XEdge
  sta Pos0GrPtr,y ; Why do I have to do this?
  lda #>XEdge
  sta Pos0GrPtr+1,y
  jmp ButtonNotPressed

AddMiddle
  lda #<XMiddle
  sta Pos0GrPtr,y
  lda #>XMiddle
  sta Pos0GrPtr+1,y

ButtonNotPressed

  ;------------------------------------------------------------------------------
  ; Check Player Win
  ; Setting up the TempPtr to pass to the checking subroutine
  lda #<HumanPlayerBoard        ; 3 (3) Store the low byte first
  sta TempPtr                   ; 3 (6) 
  lda #>HumanPlayerBoard        ; 3 (3) Store the high byte next
  sta TempPtr+1                 ; 3 (6)

  jsr CheckWinner               ; 6 + 141(worst_case) (153) six cycles for the jump
  beq NoWinner                  ; 2[3] (156) For now reset the game when there
  lda #0                        ; 2 (158)
  sta PlayerButtonActive        ; 3 (161) Turn of player button
  jmp PlayerWins                ; is a winner

NoWinner

  lda PreviousJoyStickState
  cmp SWCHA
  beq SkipMove

  lda SWCHA
  sta PreviousJoyStickState

  lda #%10000000 ;Right?
  bit SWCHA
  bne SkipMoveRight

  lda PlayerXpos
  cmp #2
  beq SkipMove

  inc PlayerXpos ; Move Position Right

SkipMoveRight

  lda #%01000000 ;left?
  bit SWCHA
  bne SkipMoveLeft

  lda PlayerXpos
  cmp #0
  beq SkipMove

  dec PlayerXpos ; Move Position Left

SkipMoveLeft

  lda #%00100000 ;down?
  bit SWCHA
  bne SkipMoveDown

  lda PlayerYpos
  cmp #2
  beq SkipMove

  inc PlayerYpos ; Move Position Left

SkipMoveDown

  lda #%00010000 ;down?
  bit SWCHA
  bne SkipMoveUp

  lda PlayerYpos
  cmp #0
  beq SkipMove

  dec PlayerYpos ; Move Position Left

SkipMoveUp

SkipMove

  rts

;------------------------------------------------------------------------------
; 192 scanlines of picture 76 cycles per scanline

Kernel
; turn on display
  sta WSYNC
  lda INTIM ; check the timer
  bne Kernel
             ; A is still 0
  sta VBLANK ; D1=0 turns off VBLANK signal (display on)

;------------------------------------------------------------------------------
; FirstRow 64 Lines per row the first and last row have 4 lines of padding
  sta WSYNC
  ; determine horizontal position of cursor
  lda PlayerXpos ; 3 Load the x position of cursor
  cmp #0         ; 2 (5)
  bne SecondPos  ; 2[3] (7)

  SLEEP 17
  sta RESP0 ; 3
  jmp EndXPos

SecondPos ; starts at (8)
  cmp #1       ; 2 (10)
  bne ThirdPos

  SLEEP 27
  sta RESP0 ; 3
  jmp EndXPos

ThirdPos
  cmp #2
  bne EndXPos

  SLEEP 37
  sta RESP0 ; 3
  jmp EndXPos

EndXPos

  sta WSYNC
  sta WSYNC
  ; determine whether sprite is on this row
  lda #<BlankCursor ; 4 (4) load the low bite of blank cursor
  sta TempPtr       ; 3 (7)
  lda #>BlankCursor ; 4 (11) load the load bite of blank cursor
  sta TempPtr+1     ; 3 (14)

  lda PlayerYpos    ; 3 (17) is the player y position 0?
  cmp #0             ; 2 (19)
  bne SkipFirstRowSpritePointer ; 3[2] (21)

  lda #<Cursor      ; 4 (25) load the low bite of cursor
  sta TempPtr       ; 3 (28)
  lda #>Cursor      ; 4 (32) load the load bite of cursor
  sta TempPtr+1     ; 3 (35)
SkipFirstRowSpritePointer

  sta WSYNC

  ldx #28       ; 2 (2)
  lda PF1       ; 3 (5) This just wastes 3 cycles to sync with the next rows
FirstRowSegment
  txa            ; 2 (7) Load graphics from tables
  lsr            ; 2 (9) Divide by 4
  tay            ; 2 (11) Transfer into y register for offsetting
  lda (Pos0GrPtr),y ; 5 (16)
  sta PF1           ; 3 (19)
  lda (Pos1GrPtr),y ; 5 (24)
  sta PF2           ; 3 (27)

  SLEEP 15

  lda (Pos2GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC
  lda (Pos0GrPtr),y ; 5 (10)
  sta PF1           ; 3 (13) ; Don't overwrite Position 1

  lda (TempPtr),y   ; 5 (18)
  sta GRP0          ; 3 (21)

  sleep 24

  lda (Pos2GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC      ; 3 THIS must happen by 73
  dex            ; 2 (2)
  bne FirstRowSegment ; 3[2] (5)

; 4 Solid lines at bottom of row
  lda #%11111111
  sta PF1
  sta PF2
  sta WSYNC
  sta WSYNC
  sta WSYNC
  sta WSYNC

;------------------------------------------------------------------------------
; Second Row

; 4 Solid lines at top of row
  sta WSYNC
  sta WSYNC
  sta WSYNC
  ; determine whether sprite is on this row
  lda #<BlankCursor ; 4 (4) load the low bite of blank cursor
  sta TempPtr       ; 3 (7)
  lda #>BlankCursor ; 4 (11) load the load bite of blank cursor
  sta TempPtr+1     ; 3 (14)

  lda PlayerYpos    ; 3 (17) is the player y position 0?
  cmp #1            ; 2 (19)
  bne SkipSecondRowSpritePointer ; 3[2] (21)

  lda #<Cursor      ; 4 (25) load the low bite of cursor
  sta TempPtr       ; 3 (28)
  lda #>Cursor      ; 4 (32) load the load bite of cursor
  sta TempPtr+1     ; 3 (35)
SkipSecondRowSpritePointer

  sta WSYNC

  ldx #28       ; 2 (2)
  lda PF1       ; 3 (5) This just wastes 3 cycles to sync with the next rows
SecondRowSegment
  txa            ; 2 (7) Load graphics from tables
  lsr            ; 2 (9) Divide by 4
  tay            ; 2 (11) Transfer into y register for offsetting
  lda (Pos3GrPtr),y ; 5 (16)
  sta PF1           ; 3 (19)
  lda (Pos4GrPtr),y ; 5 (24)
  sta PF2           ; 3 (27)

  SLEEP 15

  lda (Pos5GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC
  lda (Pos3GrPtr),y ; 5 (10)
  sta PF1           ; 3 (13) ; Don't overwrite Position 1

  lda (TempPtr),y   ; 5 (18)
  sta GRP0          ; 3 (21)

  sleep 24

  lda (Pos5GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC      ; 3 THIS must happen by 73
  dex            ; 2 (2)
  bne SecondRowSegment ; 3[2] (5)

; 4 Solid lines at bottom of row
  lda #%11111111
  sta PF1
  sta PF2
  sta WSYNC
  sta WSYNC
  sta WSYNC
  sta WSYNC

;------------------------------------------------------------------------------
; Third Row

; 4 Solid lines at top of row
  sta WSYNC
  sta WSYNC
  sta WSYNC
  ; determine whether sprite is on this row
  lda #<BlankCursor ; 4 (4) load the low bite of blank cursor
  sta TempPtr       ; 3 (7)
  lda #>BlankCursor ; 4 (11) load the load bite of blank cursor
  sta TempPtr+1     ; 3 (14)

  lda PlayerYpos    ; 3 (17) is the player y position 0?
  cmp #2            ; 2 (19)
  bne SkipThirdRowSpritePointer ; 3[2] (21)

  lda #<Cursor      ; 4 (25) load the low bite of cursor
  sta TempPtr       ; 3 (28)
  lda #>Cursor      ; 4 (32) load the load bite of cursor
  sta TempPtr+1     ; 3 (35)
SkipThirdRowSpritePointer

  sta WSYNC

  ldx #28       ; 2 (2)
  lda PF1       ; 3 (5) This just wastes 3 cycles to sync with the next rows
ThirdRowSegment
  txa            ; 2 (7) Load graphics from tables
  lsr            ; 2 (9) Divide by 4
  tay            ; 2 (11) Transfer into y register for offsetting
  lda (Pos6GrPtr),y ; 5 (16)
  sta PF1           ; 3 (19)
  lda (Pos7GrPtr),y ; 5 (24)
  sta PF2           ; 3 (27)

  SLEEP 15

  lda (Pos8GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC
  lda (Pos6GrPtr),y ; 5 (10)
  sta PF1           ; 3 (13) ; Don't overwrite Position 1

  lda (TempPtr),y   ; 5 (18)
  sta GRP0          ; 3 (21)

  sleep 24

  lda (Pos8GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC      ; 3 THIS must happen by 73
  dex            ; 2 (2)
  bne ThirdRowSegment ; 3[2] (5)

; 4 Blank lines at bottom of row
  lda #0
  sta PF1
  sta PF2
  sta WSYNC
  sta WSYNC
  sta WSYNC
  sta WSYNC

;------------------------------------------------------------------------------
; Cleanup

  lda #0                               ; Clear player graphics
  sta PF1
  sta PF2

  rts ; return from Kernel


;------------------------------------------------------------------------------
; Overscan Subroutine

Overscan
  sta WSYNC
  lda #2
  sta VBLANK ; D1=1 turn image output off

  lda #32    ; set timer for 27 scanline 27 * 76 / 64
  sta TIM64T ; set timer to tick every 64 ticks

  ; logic goes here 2052 max
osWait
  sta WSYNC
  lda INTIM
  bne osWait
  rts

;------------------------------------------------------------------------------
; CheckWinner Subroutine (141 cycles worst case if not a winner)
; Params: TempPtr pointing at one of the player's boards
; Returns: 0 or 1 on the Accumulator for false or true
; Does not preserve registers

CheckWinner
  ldx #NumWinConds   ; 4 (4) load the number of win conditions
  ldy #0            ; 2 (6) load the low byte of the board from memory

WinCheckLoop
  lda (TempPtr),y   ; 5 (11-first-pass) load the board
  and WinConds,x    ; 4 (15-first-pass) check against win conditions
  cmp WinConds,x    ; 4
  beq IsWinner      ; 3[2] (18-first-pass) if we have a winner break the loop
  dex               ; 2 (20-first-pass)
  bne WinCheckLoop  ; 3[2] (23-first-pass)
                    ; (90-worst-case) (22-best-case)

  ; Rotate the high byte onto the low byte
  ldy #1            ; 2 (92) load the high byte into the carry
  lda (TempPtr),y   ; 5 (97)
  sec               ; 2 (99) set carry for subtraction
  sbc #1            ; 2 (101) if high byte is 0 carry not set, if high byte 1
                    ; carry will still be set after subtration
  ldy #0            ; 2 (103) load the low byte again
  lda (TempPtr),y   ; 5 (108)

  ror               ; 2 (110) rotate the carry onto the board
  tax               ; 2 (112) store in x
  and #ShiftedWinConds1 ; 2 (114) check first shifted win conditions
  cmp #ShiftedWinConds1 ; 2
  beq IsWinner      ; 3[2] (116)

  txa               ; 2 (118) Load the rotated board
  and #ShiftedWinConds2 ; 2 (120) check first shifted win conditions
  cmp #ShiftedWinConds2 ; 2
  beq IsWinner      ; 3[2] (122)

  ; check the last condition rotate the carry (position 0) back onto the byte
  ; and check
  ldy #0            ; 2 (103) load the low byte again
  lda (TempPtr),y   ; 5 (108)
  ror              ; 2 (126)
  txa              ; 2 (124) Load the rotated board
  ror              ; 2 (126) rotate the carry onto the left side

  and #SpecialWinConds ; 2 (128)
  cmp #SpecialWinConds ; 2 
  beq IsWinner     ; 3[2] (130)

  ; No winners
  lda #0          ; 2 (132) Store 0 to the accumulator
  jmp EndCheckWinner ; 3 (135)

IsWinner
  lda #1           ; 2 (unknown)Store 1 to the accumulator
EndCheckWinner
  rts           ; 6 (141)

;------------------------------------------------------------------------------
; End Game Kernals
  include "player_wins.dasm"


;------------------------------------------------------------------------------
; Data Tables

  .align 256
; Top left to bottom right is not included here because it needs both position 0
; and position 9 has to be handled differently
NumWinConds = 5
WinConds
  .byte #0 ; Padding because of counting down
  .byte #%00000111 ; Top row
  .byte #%00111000 ; Middle row
  .byte #%01001001 ; Left column
  .byte #%10010010 ; Middle column
  .byte #%01010100 ; Top right to bottom left diagonal

; These are the win conditions when the board has position rotated onto the left
; side
ShiftedWinConds1 = %11100000 ; Bottom row
ShiftedWinConds2 = %10010010 ; Right column
SpecialWinConds = #%11000100 ; Top left to bottom right. Must be rotated right
                             ; twice to match

BlankEdge
  .byte #0,#0,#0,#0,#0,#0,#0
  .byte #0,#0,#0,#0,#0,#0,#0,#0 ; Why an extra?

BlankMiddle
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110 ; Why an extra?

XEdge
  .byte #%00000000
  .byte #%01000001
  .byte #%01000001
  .byte #%00100010
  .byte #%00100010
  .byte #%00010100
  .byte #%00001000
  .byte #%00001000
  .byte #%00010100
  .byte #%00100010
  .byte #%00100010
  .byte #%01000001
  .byte #%01000001
  .byte #%00000000
  .byte #%00000000 ; Why an extra?

XMiddle
  .byte #%00000110
  .byte #%00010110
  .byte #%00010110
  .byte #%00100110
  .byte #%00100110
  .byte #%01000110
  .byte #%10000110
  .byte #%10000110
  .byte #%01000110
  .byte #%00100110
  .byte #%00100110
  .byte #%00010110
  .byte #%00010110
  .byte #%00000110
  .byte #%00000110 ; Why an extra?

OEdge
  .byte #%00000000
  .byte #%00111110
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%00111110
  .byte #%00000000
  .byte #%00000000 ; Why an extra?

OMiddle
  .byte #%00000110
  .byte #%11100110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%11100110
  .byte #%00000110
  .byte #%00000110 ; Why an extra?

; Player Cursor

BlankCursor
  .byte #0,#0,#0,#0,#0,#0,#0
  .byte #0,#0,#0,#0,#0,#0,#0,#0 ; Why an extra?

Cursor
  .byte #%00000000
  .byte #%11111111
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%11111111
  .byte #%11111111
;------------------------------------------------------------------------------
  org $FFFA

InterruptVectors
  .word Reset          ; NMI
  .word Reset          ; RESET
  .word Reset          ; IRQ

  END
