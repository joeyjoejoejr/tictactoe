; TODO You may want to change the copyright of all files. This is the
; TODO ISC license. Choose another one if you want.
;
; Copyright (c) 2015 Joe Jackson <cpmhjoe@gmail.com>
;
; Permission to use, copy, modify, and/or distribute this software for any
; purpose with or without fee is hereby granted, provided that the above
; copyright notice and this permission notice appear in all copies.
;
; THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
; WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
; MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
; ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
; WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
; ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
; OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

  processor 6502
  include "vcs.h"
  include "macro.h"

;------------------------------------------------------------------------------
; Variables

  seg.u vars
  org $80                             ; start of RAM

; pointers to the graphics for each slot
Pos0GrPtr ds 2
Pos1GrPtr ds 2
Pos2GrPtr ds 2
Pos3GrPtr ds 2
Pos4GrPtr ds 2
Pos5GrPtr ds 2
Pos6GrPtr ds 2
Pos7GrPtr ds 2
Pos8GrPtr ds 2

; Player Cursor xPos (0-2) yPos (0-2)
PlayerXpos ds 1
PlayerYpos ds 1

; Temporary Pointer
TempPtr ds 2

PreviousJoyStickState ds 1

; 20 bytes 236 left

;------------------------------------------------------------------------------

  seg
  org $F000

Reset
  ; clear RAM and all TIA registers

  ldx #0
  lda #0
Clear sta 0,x
  inx
  bne Clear

  ldx #$FF
  txs                                 ; set stack pointer

;------------------------------------------------------------------------------
; Once only initialization

  lda #%00000001                      ; reflected playfield
  sta CTRLPF

  lda #$0e                            ; white board
  sta COLUPF                          ; set playfield color

  lda #$46
  sta COLUP0                          ; Player Sprite is Red

  ; load all of slots with empty graphics
  lda #<BlankEdge
  sta Pos0GrPtr
  lda #>BlankEdge
  sta Pos0GrPtr+1

  lda #<BlankMiddle
  sta Pos1GrPtr
  lda #>BlankMiddle
  sta Pos1GrPtr+1

  lda #<BlankEdge
  sta Pos2GrPtr
  lda #>BlankEdge
  sta Pos2GrPtr+1

  lda #<BlankEdge
  sta Pos3GrPtr
  lda #>BlankEdge
  sta Pos3GrPtr+1

  lda #<BlankMiddle
  sta Pos4GrPtr
  lda #>BlankMiddle
  sta Pos4GrPtr+1

  lda #<BlankEdge
  sta Pos5GrPtr
  lda #>BlankEdge
  sta Pos5GrPtr+1

  lda #<BlankEdge
  sta Pos6GrPtr
  lda #>BlankEdge
  sta Pos6GrPtr+1

  lda #<BlankMiddle
  sta Pos7GrPtr
  lda #>BlankMiddle
  sta Pos7GrPtr+1

  lda #<BlankEdge
  sta Pos8GrPtr
  lda #>BlankEdge
  sta Pos8GrPtr+1

  ; set player to 0,0
  lda #1
  sta PlayerXpos
  lda #1
  sta PlayerYpos

  ; quadruple sprite size
  lda #%0000111
  sta NUSIZ0

  ; set joystick state to 0
  lda #0
  sta PreviousJoyStickState

;------------------------------------------------------------------------------
; Main Loop
Main
  jsr VerticalSync  ; 6 Jump to Vertical Sync
  jsr VerticalBlank ; 6 Jump to Vertical Blank
  jsr Kernel        ; 6 Jump to Kernel
  jsr Overscan      ; 6 Jump to Overscan
  jmp Main

;------------------------------------------------------------------------------
; VerticalSync Subroutine
VerticalSync
  lda #2      ; 2 Load with 2 so D1=1 to turn on VSYNC signal
  ldx #49

  sta WSYNC
  sta VSYNC ; D1=1 turns the Vertical Sync signal on
  stx TIM64T ; set timer to go of in 41 scanlines 49 = (41 * 76) / 64

  sta WSYNC
  sta WSYNC

  lda #0
  sta WSYNC                           ; 3rd scanline of VSYNC signal
  sta VSYNC                           ; D1 = 0 Turns Off VSYNC signal
  rts

;------------------------------------------------------------------------------
; VerticleBlank Subroutine 37 lines 37 * 76 = 2815 cycles max

VerticalBlank
  lda INPT4
  bmi ButtonNotPressed

  lda PlayerYpos   ; load y-pos and multiply by 3
  adc PlayerYpos
  adc PlayerYpos

  adc PlayerXpos  ; get final position ex y=1 x=2  3 x 1 + 2 = 5
  asl             ; multipy by 2 to get offset

  tay             ; transfer y to a

  lda PlayerXpos  ; check if xpos is middle
  cmp #1
  beq AddMiddle

  lda #<XEdge
  sta Pos0GrPtr-2,y
  lda #>XEdge
  sta Pos0GrPtr-1,y
  jmp ButtonNotPressed

AddMiddle
  lda #<XMiddle
  sta Pos0GrPtr-2,y
  lda #>XMiddle
  sta Pos0GrPtr-1,y

ButtonNotPressed

  lda PreviousJoyStickState
  cmp SWCHA
  beq SkipMove

  lda SWCHA
  sta PreviousJoyStickState

  lda #%10000000 ;Right?
  bit SWCHA
  bne SkipMoveRight

  lda PlayerXpos
  cmp #2
  beq SkipMove

  inc PlayerXpos ; Move Position Right

SkipMoveRight

  lda #%01000000 ;left?
  bit SWCHA
  bne SkipMoveLeft

  lda PlayerXpos
  cmp #0
  beq SkipMove

  dec PlayerXpos ; Move Position Left

SkipMoveLeft

  lda #%00100000 ;down?
  bit SWCHA
  bne SkipMoveDown

  lda PlayerYpos
  cmp #2
  beq SkipMove

  inc PlayerYpos ; Move Position Left

SkipMoveDown

  lda #%00010000 ;down?
  bit SWCHA
  bne SkipMoveUp

  lda PlayerYpos
  cmp #0
  beq SkipMove

  dec PlayerYpos ; Move Position Left

SkipMoveUp

SkipMove

  rts

;------------------------------------------------------------------------------
; 192 scanlines of picture 76 cycles per scanline

Kernel
; turn on display
  sta WSYNC
  lda INTIM ; check the timer
  bne Kernel
             ; A is still 0
  sta VBLANK ; D1=0 turns off VBLANK signal (display on)

;------------------------------------------------------------------------------
; FirstRow 64 Lines per row the first and last row have 4 lines of padding
  sta WSYNC
  ; determine horizontal position of cursor
  lda PlayerXpos ; 3 Load the x position of cursor
  cmp #0         ; 2 (5)
  bne SecondPos  ; 2[3] (7)

  SLEEP 17
  sta RESP0 ; 3
  jmp EndXPos

SecondPos ; starts at (8)
  cmp #1       ; 2 (10)
  bne ThirdPos

  SLEEP 27
  sta RESP0 ; 3
  jmp EndXPos

ThirdPos
  cmp #2
  bne EndXPos

  SLEEP 37
  sta RESP0 ; 3
  jmp EndXPos

EndXPos

  sta WSYNC
  sta WSYNC
  ; determine whether sprite is on this row
  lda #<BlankCursor ; 4 (4) load the low bite of blank cursor
  sta TempPtr       ; 3 (7)
  lda #>BlankCursor ; 4 (11) load the load bite of blank cursor
  sta TempPtr+1     ; 3 (14)

  lda PlayerYpos    ; 3 (17) is the player y position 0?
  cmp #0             ; 2 (19)
  bne SkipFirstRowSpritePointer ; 3[2] (21)

  lda #<Cursor      ; 4 (25) load the low bite of cursor
  sta TempPtr       ; 3 (28)
  lda #>Cursor      ; 4 (32) load the load bite of cursor
  sta TempPtr+1     ; 3 (35)
SkipFirstRowSpritePointer

  sta WSYNC

  ldx #28       ; 2 (2)
  lda PF1       ; 3 (5) This just wastes 3 cycles to sync with the next rows
FirstRowSegment
  txa            ; 2 (7) Load graphics from tables
  lsr            ; 2 (9) Divide by 4
  tay            ; 2 (11) Transfer into y register for offsetting
  lda (Pos0GrPtr),y ; 5 (16)
  sta PF1           ; 3 (19)
  lda (Pos1GrPtr),y ; 5 (24)
  sta PF2           ; 3 (27)

  SLEEP 15

  lda (Pos2GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC
  lda (Pos0GrPtr),y ; 5 (10)
  sta PF1           ; 3 (13) ; Don't overwrite Position 1

  lda (TempPtr),y   ; 5 (18)
  sta GRP0          ; 3 (21)

  sleep 24

  lda (Pos2GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC      ; 3 THIS must happen by 73
  dex            ; 2 (2)
  bne FirstRowSegment ; 3[2] (5)

; 4 Solid lines at bottom of row
  lda #%11111111
  sta PF1
  sta PF2
  sta WSYNC
  sta WSYNC
  sta WSYNC
  sta WSYNC

;------------------------------------------------------------------------------
; Second Row

; 4 Solid lines at top of row
  sta WSYNC
  sta WSYNC
  sta WSYNC
  ; determine whether sprite is on this row
  lda #<BlankCursor ; 4 (4) load the low bite of blank cursor
  sta TempPtr       ; 3 (7)
  lda #>BlankCursor ; 4 (11) load the load bite of blank cursor
  sta TempPtr+1     ; 3 (14)

  lda PlayerYpos    ; 3 (17) is the player y position 0?
  cmp #1            ; 2 (19)
  bne SkipSecondRowSpritePointer ; 3[2] (21)

  lda #<Cursor      ; 4 (25) load the low bite of cursor
  sta TempPtr       ; 3 (28)
  lda #>Cursor      ; 4 (32) load the load bite of cursor
  sta TempPtr+1     ; 3 (35)
SkipSecondRowSpritePointer

  sta WSYNC

  ldx #28       ; 2 (2)
  lda PF1       ; 3 (5) This just wastes 3 cycles to sync with the next rows
SecondRowSegment
  txa            ; 2 (7) Load graphics from tables
  lsr            ; 2 (9) Divide by 4
  tay            ; 2 (11) Transfer into y register for offsetting
  lda (Pos3GrPtr),y ; 5 (16)
  sta PF1           ; 3 (19)
  lda (Pos4GrPtr),y ; 5 (24)
  sta PF2           ; 3 (27)

  SLEEP 15

  lda (Pos5GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC
  lda (Pos3GrPtr),y ; 5 (10)
  sta PF1           ; 3 (13) ; Don't overwrite Position 1

  lda (TempPtr),y   ; 5 (18)
  sta GRP0          ; 3 (21)

  sleep 24

  lda (Pos5GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC      ; 3 THIS must happen by 73
  dex            ; 2 (2)
  bne SecondRowSegment ; 3[2] (5)

; 4 Solid lines at bottom of row
  lda #%11111111
  sta PF1
  sta PF2
  sta WSYNC
  sta WSYNC
  sta WSYNC
  sta WSYNC

;------------------------------------------------------------------------------
; Third Row

; 4 Solid lines at top of row
  sta WSYNC
  sta WSYNC
  sta WSYNC
  ; determine whether sprite is on this row
  lda #<BlankCursor ; 4 (4) load the low bite of blank cursor
  sta TempPtr       ; 3 (7)
  lda #>BlankCursor ; 4 (11) load the load bite of blank cursor
  sta TempPtr+1     ; 3 (14)

  lda PlayerYpos    ; 3 (17) is the player y position 0?
  cmp #2            ; 2 (19)
  bne SkipThirdRowSpritePointer ; 3[2] (21)

  lda #<Cursor      ; 4 (25) load the low bite of cursor
  sta TempPtr       ; 3 (28)
  lda #>Cursor      ; 4 (32) load the load bite of cursor
  sta TempPtr+1     ; 3 (35)
SkipThirdRowSpritePointer

  sta WSYNC

  ldx #28       ; 2 (2)
  lda PF1       ; 3 (5) This just wastes 3 cycles to sync with the next rows
ThirdRowSegment
  txa            ; 2 (7) Load graphics from tables
  lsr            ; 2 (9) Divide by 4
  tay            ; 2 (11) Transfer into y register for offsetting
  lda (Pos6GrPtr),y ; 5 (16)
  sta PF1           ; 3 (19)
  lda (Pos7GrPtr),y ; 5 (24)
  sta PF2           ; 3 (27)

  SLEEP 15

  lda (Pos8GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC
  lda (Pos6GrPtr),y ; 5 (10)
  sta PF1           ; 3 (13) ; Don't overwrite Position 1

  lda (TempPtr),y   ; 5 (18)
  sta GRP0          ; 3 (21)

  sleep 24

  lda (Pos8GrPtr),y ; 5 (42) PF1 has been drawn it's safe to change the graphic
  sta PF1           ; 3 (45)

  sta WSYNC      ; 3 THIS must happen by 73
  dex            ; 2 (2)
  bne ThirdRowSegment ; 3[2] (5)

; 4 Blank lines at bottom of row
  lda #0
  sta PF1
  sta PF2
  sta WSYNC
  sta WSYNC
  sta WSYNC
  sta WSYNC

;------------------------------------------------------------------------------
; Cleanup

  lda #0                               ; Clear player graphics
  sta PF1
  sta PF2

  rts ; return from Kernel


;------------------------------------------------------------------------------
; Overscan Subroutine

Overscan
  sta WSYNC
  lda #2
  sta VBLANK ; D1=1 turn image output off

  lda #32    ; set timer for 27 scanline 27 * 76 / 64
  sta TIM64T ; set timer to tick every 64 ticks

  ; logic goes here 2052 max
osWait
  sta WSYNC
  lda INTIM
  bne osWait
  rts

;------------------------------------------------------------------------------
; Data Tables

  .align 256
BlankEdge
  .byte #0,#0,#0,#0,#0,#0,#0
  .byte #0,#0,#0,#0,#0,#0,#0,#0 ; Why an extra?

BlankMiddle
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110
  .byte #%00000110 ; Why an extra?

XEdge
  .byte #%00000000
  .byte #%01000001
  .byte #%01000001
  .byte #%00100010
  .byte #%00100010
  .byte #%00010100
  .byte #%00001000
  .byte #%00001000
  .byte #%00010100
  .byte #%00100010
  .byte #%00100010
  .byte #%01000001
  .byte #%01000001
  .byte #%00000000
  .byte #%00000000 ; Why an extra?

XMiddle
  .byte #%00000110
  .byte #%00010110
  .byte #%00010110
  .byte #%00100110
  .byte #%00100110
  .byte #%01000110
  .byte #%10000110
  .byte #%10000110
  .byte #%01000110
  .byte #%00100110
  .byte #%00100110
  .byte #%00010110
  .byte #%00010110
  .byte #%00000110
  .byte #%00000110 ; Why an extra?

OEdge
  .byte #%00000000
  .byte #%00111110
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%01000001
  .byte #%00111110
  .byte #%00000000
  .byte #%00000000 ; Why an extra?

OMiddle
  .byte #%00000110
  .byte #%11100110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%00010110
  .byte #%11100110
  .byte #%00000110
  .byte #%00000110 ; Why an extra?

; Player Cursor

BlankCursor
  .byte #0,#0,#0,#0,#0,#0,#0
  .byte #0,#0,#0,#0,#0,#0,#0,#0 ; Why an extra?

Cursor
  .byte #%00000000
  .byte #%11111111
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%10000001
  .byte #%11111111
  .byte #%11111111
;------------------------------------------------------------------------------
  org $FFFA

InterruptVectors
  .word Reset          ; NMI
  .word Reset          ; RESET
  .word Reset          ; IRQ

  END
